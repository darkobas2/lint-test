# organization-actions/.github/workflows/yaml-lint-security.yml
#
# Reusable workflow for YAML linting and security scanning
# Uses a GitHub App for auto-commit to maintain audit trail
#
# Setup:
#   1. Create GitHub App (see docs/LINT_BOT_SETUP.md)
#   2. Add secrets to org: LINT_BOT_APP_ID, LINT_BOT_PRIVATE_KEY
#   3. Call this workflow from your repos

name: YAML Lint + Security

on:
  workflow_call:
    inputs:
      # === General Settings ===
      auto_fix:
        description: 'Auto-commit lint fixes (requires GitHub App secrets)'
        type: boolean
        default: true

      # === Shared Config URLs ===
      pre_commit_config_url:
        description: 'URL to shared pre-commit config (optional, uses local if not set)'
        type: string
        default: 'https://raw.githubusercontent.com/darkobas2/lint-test/refs/heads/main/.pre-commit-config.yml'
      yamllint_config_url:
        description: 'URL to shared yamllint config (optional)'
        type: string
        default: 'https://raw.githubusercontent.com/darkobas2/lint-test/refs/heads/main/.yamllint.yml'

      # === Checkov Security Scanning ===
      checkov_enabled:
        description: 'Run Checkov security scanning'
        type: boolean
        default: true
      checkov_soft_fail:
        description: 'Allow Checkov failures without blocking'
        type: boolean
        default: true
      checkov_skip_checks:
        description: 'Comma-separated list of Checkov checks to skip'
        type: string
        default: ''
      checkov_framework:
        description: 'Checkov frameworks to run'
        type: string
        default: 'kubernetes,helm,secrets'

      # === Trivy Security Scanning ===
      trivy_enabled:
        description: 'Run Trivy security scanning'
        type: boolean
        default: true
      trivy_soft_fail:
        description: 'Allow Trivy failures without blocking'
        type: boolean
        default: true
      trivy_skip_dirs:
        description: 'Comma-separated list of directories for Trivy to skip'
        type: string
        default: '.git,.github'

      # === Helm Linting ===
      helm_lint_enabled:
        description: 'Run Helm lint on charts'
        type: boolean
        default: true
    secrets:
      LINT_BOT_APP_ID:
        description: 'GitHub App ID for lint-bot'
        required: false
      LINT_BOT_PRIVATE_KEY:
        description: 'GitHub App private key for lint-bot'
        required: false

jobs:
  lint:
    name: Lint & Format
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      fixed: ${{ steps.changes.outputs.has_changes }}
    steps:
      - name: Initial checkout to check commit author
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          ref: ${{ github.event.pull_request.head.ref || github.ref }}

      - name: Check if commit is from lint-bot
        id: check-bot
        run: |
          AUTHOR=$(git log -1 --format='%an')
          MESSAGE=$(git log -1 --format='%s')
          echo "Last commit author: $AUTHOR"
          echo "Last commit message: $MESSAGE"

          if [[ "$AUTHOR" == "lint-bot[bot]" ]] || [[ "$MESSAGE" == "style: auto-fix linting issues" ]]; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
            echo "‚úì Skipping lint - commit is from lint-bot"
          else
            echo "is_bot=false" >> $GITHUB_OUTPUT
            echo "‚Üí Running lint - commit is from user"
          fi

      - name: Check if GitHub App is configured
        if: steps.check-bot.outputs.is_bot != 'true'
        id: check-app
        env:
          APP_ID: ${{ secrets.LINT_BOT_APP_ID }}
        run: |
          if [[ -n "$APP_ID" ]]; then
            echo "available=true" >> $GITHUB_OUTPUT
          else
            echo "available=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate GitHub App Token
        id: app-token
        if: steps.check-bot.outputs.is_bot != 'true' && inputs.auto_fix && steps.check-app.outputs.available == 'true'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.LINT_BOT_APP_ID }}
          private-key: ${{ secrets.LINT_BOT_PRIVATE_KEY }}

      - name: Checkout (with App token for push)
        if: steps.check-bot.outputs.is_bot != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Setup Python
        if: steps.check-bot.outputs.is_bot != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pre-commit
        if: steps.check-bot.outputs.is_bot != 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cache/pre-commit
          key: pre-commit-${{ hashFiles('.pre-commit-config.yaml') }}
          restore-keys: |
            pre-commit-

      # Fetch shared configs if URLs provided
      - name: Fetch shared pre-commit config
        if: steps.check-bot.outputs.is_bot != 'true' && inputs.pre_commit_config_url != ''
        run: |
          echo "Fetching pre-commit config from ${{ inputs.pre_commit_config_url }}"
          curl -sSfL "${{ inputs.pre_commit_config_url }}" -o .pre-commit-config.yaml

      - name: Fetch shared yamllint config
        if: steps.check-bot.outputs.is_bot != 'true' && inputs.yamllint_config_url != ''
        run: |
          echo "Fetching yamllint config from ${{ inputs.yamllint_config_url }}"
          curl -sSfL "${{ inputs.yamllint_config_url }}" -o .yamllint

      - name: Install pre-commit
        if: steps.check-bot.outputs.is_bot != 'true'
        run: pip install pre-commit

      - name: Run pre-commit
        if: steps.check-bot.outputs.is_bot != 'true'
        id: pre-commit
        run: |
          pre-commit run --all-files 2>&1 | tee pre-commit-output.txt || echo "pre_commit_failed=true" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Check for changes
        if: steps.check-bot.outputs.is_bot != 'true'
        id: changes
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Files modified by pre-commit:"
            git status --porcelain
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      # Auto-commit with GitHub App (maintains audit trail)
      - name: Commit and push fixes
        if: steps.check-bot.outputs.is_bot != 'true' && steps.changes.outputs.has_changes == 'true' && inputs.auto_fix && steps.check-app.outputs.available == 'true'
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git config user.name "lint-bot[bot]"
          git config user.email "${{ secrets.LINT_BOT_APP_ID }}+lint-bot[bot]@users.noreply.github.com"

          git add -A
          git commit -m "style: auto-fix linting issues

          Co-authored-by: ${{ github.event.pull_request.user.login }} <${{ github.event.pull_request.user.id }}+${{ github.event.pull_request.user.login }}@users.noreply.github.com>"

          git push

      # Fail if pre-commit failed and no auto-fix
      - name: Fail if issues remain
        if: steps.check-bot.outputs.is_bot != 'true' && steps.pre-commit.outputs.pre_commit_failed == 'true' && (steps.check-app.outputs.available == 'false' || !inputs.auto_fix)
        run: |
          echo "::error::Pre-commit found issues. See PR comment for fix instructions."
          exit 1

  helm-lint:
    name: Helm Lint
    if: inputs.helm_lint_enabled
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Find Helm charts
        id: find-charts
        run: |
          charts=()

          # Check if Chart.yaml exists in root
          if [[ -f "Chart.yaml" ]]; then
            echo "Found chart in root directory"
            charts+=(".")
          fi

          # Find charts in subdirectories
          while IFS= read -r chart; do
            chart_dir=$(dirname "$chart")
            echo "Found chart in $chart_dir"
            charts+=("$chart_dir")
          done < <(find . -mindepth 2 -name "Chart.yaml" -not -path "*/\.*")

          if [[ ${#charts[@]} -eq 0 ]]; then
            echo "No Helm charts found"
            echo "charts_found=false" >> $GITHUB_OUTPUT
          else
            echo "charts_found=true" >> $GITHUB_OUTPUT
            # Join array with newlines
            printf "%s\n" "${charts[@]}" > charts.txt
          fi

      - name: Lint Helm charts
        if: steps.find-charts.outputs.charts_found == 'true'
        run: |
          failed=0
          while IFS= read -r chart; do
            echo "::group::Linting $chart"
            if helm lint "$chart"; then
              echo "‚úì $chart passed"
            else
              echo "‚úó $chart failed"
              failed=1
            fi
            echo "::endgroup::"
          done < charts.txt

          if [[ $failed -eq 1 ]]; then
            echo "::error::One or more Helm charts failed linting"
            exit 1
          fi

  security:
    name: Security Scan
    if: inputs.checkov_enabled || inputs.trivy_enabled
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      security-events: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            **.yaml
            **.yml
            charts/**
            Chart.yaml

      - name: Run Checkov
        if: inputs.checkov_enabled && steps.changed-files.outputs.any_changed == 'true'
        id: checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: .
          framework: ${{ inputs.checkov_framework }}
          soft_fail: ${{ inputs.checkov_soft_fail }}
          output_format: cli,sarif
          output_file_path: console,checkov-results.sarif
          compact: true
          quiet: false
          skip_check: ${{ inputs.checkov_skip_checks }}

      # Upload Checkov SARIF
      - name: Upload Checkov SARIF
        if: always() && inputs.checkov_enabled && steps.changed-files.outputs.any_changed == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: checkov-results.sarif
          category: Checkov
        continue-on-error: true

      # Run Trivy scan (always succeeds to ensure SARIF upload for code scanning)
      - name: Run Trivy vulnerability scanner
        if: inputs.trivy_enabled
        id: trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
          skip-dirs: ${{ inputs.trivy_skip_dirs }}
          scanners: 'vuln,secret,config'
          exit-code: '0'
        continue-on-error: false

      # Upload Trivy SARIF
      - name: Upload Trivy SARIF
        if: always() && inputs.trivy_enabled
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif
          category: Trivy
        continue-on-error: true

      # Check Trivy results and set output
      - name: Check Trivy SARIF for issues
        if: inputs.trivy_enabled
        id: trivy-check
        run: |
          if [[ -f "trivy-results.sarif" ]]; then
            # Count results in SARIF (jq would be cleaner but may not be available)
            if grep -q '"results":\s*\[\s*{' trivy-results.sarif; then
              echo "has_issues=true" >> $GITHUB_OUTPUT
              echo "Trivy found security issues"
            else
              echo "has_issues=false" >> $GITHUB_OUTPUT
              echo "Trivy found no issues"
            fi
          else
            echo "has_issues=false" >> $GITHUB_OUTPUT
          fi

      - name: Comment security scan results
        if: always() && (inputs.checkov_enabled || inputs.trivy_enabled) && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const checkovEnabled = ${{ inputs.checkov_enabled }};
            const trivyEnabled = ${{ inputs.trivy_enabled }};
            const checkovResult = '${{ steps.checkov.outcome }}';
            const softFail = ${{ inputs.checkov_soft_fail }};

            let body = '## üîí Security Scan Results\n\n';
            let hasFindings = false;

            // Checkov results
            if (checkovEnabled && checkovResult !== 'skipped') {
              body += '### Checkov\n';
              if (checkovResult === 'success') {
                body += '‚úÖ No issues found\n\n';
              } else if (checkovResult === 'failure') {
                body += softFail
                  ? '‚ö†Ô∏è Issues found (soft-fail mode)\n\n'
                  : '‚ùå Issues found - must be fixed\n\n';
                hasFindings = true;
              }
            }

            // Trivy results
            const trivyHasIssues = '${{ steps.trivy-check.outputs.has_issues }}';
            const trivySoftFail = ${{ inputs.trivy_soft_fail }};
            if (trivyEnabled && trivyHasIssues !== '') {
              body += '### Trivy\n';
              if (trivyHasIssues === 'false') {
                body += '‚úÖ No issues found\n\n';
              } else if (trivyHasIssues === 'true') {
                body += trivySoftFail
                  ? '‚ö†Ô∏è Issues found (soft-fail mode)\n\n'
                  : '‚ùå Issues found - must be fixed\n\n';
                hasFindings = true;
              }
            }

            // Links to results
            body += '---\n\n';
            body += 'üìä **View detailed results:**\n';
            if (context.payload.pull_request) {
              body += `- [Issues in this PR](https://github.com/${context.repo.owner}/${context.repo.repo}/security/code-scanning?query=is:open+pr:${context.payload.pull_request.number})\n`;
              body += `- [All Code Scanning Alerts](https://github.com/${context.repo.owner}/${context.repo.repo}/security/code-scanning)\n\n`;
            } else {
              body += `- [Code Scanning Alerts](https://github.com/${context.repo.owner}/${context.repo.repo}/security/code-scanning)\n\n`;
            }

            // Local testing instructions
            if (hasFindings) {
              body += '<details><summary>üîß Run scans locally</summary>\n\n';
              if (checkovEnabled) {
                body += '**Checkov:**\n```bash\npip install checkov\n';
                body += 'checkov -d . --framework ${{ inputs.checkov_framework }}\n```\n\n';
              }
              if (trivyEnabled) {
                body += '**Trivy:**\n```bash\n';
                body += 'trivy fs --severity CRITICAL,HIGH,MEDIUM .\n```\n';
              }
              body += '</details>';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Fail if security issues found
        if: |
          (steps.checkov.outcome == 'failure' && !inputs.checkov_soft_fail) ||
          (steps.trivy-check.outputs.has_issues == 'true' && !inputs.trivy_soft_fail)
        run: |
          echo "::error::Security scan failed - issues must be fixed before merging"
          if [[ "${{ steps.checkov.outcome }}" == "failure" && "${{ inputs.checkov_soft_fail }}" == "false" ]]; then
            echo "  - Checkov found security issues"
          fi
          if [[ "${{ steps.trivy-check.outputs.has_issues }}" == "true" && "${{ inputs.trivy_soft_fail }}" == "false" ]]; then
            echo "  - Trivy found vulnerabilities or misconfigurations"
          fi
          exit 1
